from django.contrib.auth import logout as logout_user
from django.http import HttpResponse,Http404,HttpResponseRedirect
from django.template import Context, loader, RequestContext

from django.shortcuts import get_object_or_404,render_to_response

from hc.core.utils.hc.datahelper import Datahelper
from hc.core.utils.hc.stats import Stats

from hc.core.base.views.json.records import get_records
from django.db.models import Min,Max,Count


#######################################################
## DEFAULT CONTEXT
#######################################################

def defaultContext(request):

  request_path = request.path
  
  app = request_path.split('/')[3]
  if request_path.find('admin')>-1:
    request_path = reverse('index-view')

  return {'app':app, 'user':request.user, 'request_path':request_path}

#######################################################
## LOGIN VIEWS
#######################################################

def logout(request):
  logout_user(request)
  next = request.GET.get('next', None)
  if next:
    return HttpResponseRedirect(next)
  else:
    raise Http404

class GenericView():

#######################################################
## INDEX BLOCK
#######################################################

  def index(self,request,dic={'Test':None},*args,**kwargs):

    test = dic['Test']
    app  = test.__module__.split('.')[1]

    stress, functional = [], []

    stress +=  test.objects.jobs('running'    ,'stress'     ,1)
    stress +=  test.objects.jobs('running'    ,'functional' ,0)
    stress +=  test.objects.jobs('submitting' ,'stress'     ,1)
    stress +=  test.objects.jobs('submitting' ,'functional' ,0)
    stress +=  test.objects.jobs('scheduled'  ,'stress'     ,1)
    stress +=  test.objects.jobs('scheduled'  ,'functional' ,0)
             
    
    functional +=  test.objects.jobs('running'    ,'functional' ,1) 
    functional +=  test.objects.jobs('submitting' ,'functional' ,1) 
    functional +=  test.objects.jobs('scheduled'  ,'functional' ,1)
                 

    dh         = Datahelper()
    stress     = dh.annotateTests(stress)
    functional = dh.annotateTests(functional)

    tests = {'stress':stress,'functional':functional}

    t = loader.select_template(['%s/index.html'%(app),'core/app/index.html'])
    c = RequestContext(request,
                       {'tests':tests},
                       [defaultContext]
                       )
    return HttpResponse(t.render(c))

#######################################################
## CLOUDS BLOCK
#######################################################

  def clouds(self,request,dic={'Cloud':None},*args,**kwargs):

    cloud = dic['Cloud']
    app   = cloud.__module__.split('.')[1]

#    clouds = Cloud.objects.exclude(name__startswith='ALL').order_by('code')
    try:
      clouds = cloud.objects.all().order_by('code') 
    except:
      raise Http404

    t = loader.select_template(['%s/clouds.html'%(app),'core/app/clouds.html'])
    c = RequestContext(request,
                       {'clouds': clouds},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))

  def cloud(self,request,cloud_id,dic={'Cloud':None},*args,**kwargs):

    cloud = dic['Cloud']
    app   = cloud.__module__.split('.')[1]

    try:
      cloud = cloud.objects.get(pk=cloud_id)
    except:
      raise Http404

#    #ALL_PANDA and ALL_LCG are not displayed
#    if cloud.name.startswith('ALL'):
#      raise Http404

#    dh = HCDataHelper()
    cloud.charts = []
#    cloud.charts.append(dh.getChartUsg('running','Running Jobs',cloud_id=cloud_id))
#   cloud.charts.append(dh.getChartUsg('completed','Completed Jobs',cloud=cloud_id))
    cloud.sites = cloud.getSites_for_cloud.all()
   
    t = loader.select_template(['%s/cloud.html'%(app),'core/app/cloud.html'])
    c = RequestContext(request,
                       {'cloud': cloud},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))


#######################################################
## DSPATTERNS BLOCK
#######################################################

  def dspatterns(self,request,dic={'Dspattern':None},*args,**kwargs):

    dspattern = dic['Dspattern']
    app       = dspattern.__module__.split('.')[1]

    try:
      dspatterns = dspattern.objects.all()
    except:
      raise Http404

    t = loader.select_template(['%s/dspatterns.html'%(app),'core/app/dspatterns.html'])
    c = RequestContext(request,
                       {'dspatterns': dspatterns},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))


#######################################################
## FILES BLOCK
#######################################################

  def files(self,request,dic={'File':None},*args,**kwargs):

    file = dic['File']
    app  = file.__module__.split('.')[1]

    try:
      files = file.objects.all()
    except:
      raise Http404

    t = loader.select_template(['%s/files.html'%(app),'core/app/files.html'])
    c = RequestContext(request,
                       {'files': files},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))


#######################################################
## HOSTS BLOCK
#######################################################

  def hosts(self,request,dic={'Host':None},*args,**kwargs):

    host = dic['Host']
    app  = host.__module__.split('.')[1]

    try:
      hosts = host.objects.all()
    except:
      raise Http404

    t = loader.select_template(['%s/hosts.html'%(app),'core/app/hosts.html'])
    c = RequestContext(request,
                       {'hosts': hosts},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))

  def host(self,request,host_id,dic={'Host':None},*args,**kwargs):

    host = dic['Host']
    app  = host.__module__.split('.')[1]

    try:
      host = host.objects.get(pk=host_id)
    except:
      raise Http404

    t = loader.select_template(['%s/host.html'%(app),'core/app/host.html'])
    c = RequestContext(request,
                       {'host': host},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))


#######################################################
## METRICS BLOCK
#######################################################

  def metric_types(self,request,dic={'MetricType':None},*args,**kwargs):

    metric_type = dic['MetricType']
    app         = metric_type.__module__.split('.')[1]

    try:
      metric_types = metric_type.objects.all()
    except:
      raise Http404

    t = loader.select_template(['%s/metric_types.html'%(app),'core/app/metric_types.html'])
    c = RequestContext(request,
                       {'metric_types': metric_types},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))

  def metric_type(self,request,metric_type_id,dic={'MetricType':None},*args,**kwargs):

    metric_type = dic['MetricType']
    app         = metric_type.__module__.split('.')[1]

    try:
      metric_type = metric_type.objects.get(pk=metric_type_id)
    except:
      raise Http404

    t = loader.select_template(['%s/metric_type.html'%(app),'core/app/metric_type.html'])
    c = RequestContext(request,
                       {'metric_type': metric_type},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))


#######################################################
## SITES BLOCK
#######################################################

  def sites(self,request,dic={'Site':None},*args,**kwargs):

    site = dic['Site']
    app  = site.__module__.split('.')[1]

    try:
      sites = site.objects.all()
#    except ObjectDoesNotExist:
#      raise Http404
#    except AttributeError:
#      raise Http500
    except:
      raise Http404
 
    t = loader.select_template(['%s/sites.html'%(app),'core/app/sites.html'])
    c = RequestContext(request,
                      {'sites': sites},
                      [defaultContext]
                      )
    return HttpResponse(t.render(c))

  def site(self,request,site_id,dic={'Site':None},*args,**kwargs):

    app = dic['Site'].__module__.split('.')[1]

    try:
      site = dic['Site'].objects.get(pk=site_id)
#    except ObjectDoesNotExist:
#      raise Http404
#    except AttributeError:
#      raise Http500
    except:
      raise Http404

#    dh = HCDataHelper()
    site.charts = []
#    site.charts.append(dh.getChartUsg('running','Running Jobs',site=site_id))
#        site.charts.append(dh.getChartUsg('completed','Completed Jobs',site=site_id))
   
    t = loader.select_template(['%s/site.html'%(app),'core/app/site.html'])
    c = RequestContext(request,
                       {'site': site},
                       [defaultContext]
                       )
    return HttpResponse(t.render(c))


#######################################################
## TEMPLATES BLOCK
#######################################################

  def templates(self,request,dic={'Template':None},*args,**kwargs):

    template = dic['Template']
    app      = template.__module__.split('.')[1]

    try:
      templates = template.objects.all()
    except:
      raise Http404

    t = loader.select_template(['%s/templates.html'%(app),'core/app/templates.html'])
    c = RequestContext(request,
                       {'templates': templates},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))   

  def template(self,request,template_id,dic={'Template':None},*args,**kwargs):

    template = dic['Template']
    app      = template.__module__.split('.')[1]

    try:
      template = template.objects.get(pk=template_id)
#    except ObjectDoesNotExist:
#      raise Http404
#    except AttributeError:
#      raise Http500
    except:
      raise Http404

    template.hosts      = template.getTemplateHosts_for_template.all()
    template.sites      = template.getTemplateSites_for_template.all()
    template.dspatterns = template.getTemplateDspatterns_for_template.all()

    t = loader.select_template(['%s/template.html'%(app),'core/app/template.html'])
    c = RequestContext(request,
                       {'template': template},
                       [defaultContext]
                      )
    return HttpResponse(t.render(c))


#######################################################
## TESTS BLOCK
#######################################################


  def test(self,request,test_id,dic={'Test':None},*args,**kwargs):

    test = dic['Test']
    app  = test.__module__.split('.')[1]

    test = get_object_or_404(test,pk=test_id)
    dh         = Datahelper()
    test = dh.annotateTest(test)

    metrics = test.metrics.index.all()

    summary = ''
    if test.getSummaryTests_for_test.count():
      summary = test.getSummaryTests_for_test.all()[0]  

    #Independently of the number of metrics selected on the MetricPermissions.index,
    #for the test main page only the 3 first ones are selected.

    test_metrics = test.getTestMetrics_for_test.filter(metric__metric_type__in=metrics)[:3]

    t = loader.select_template(['%s/test.html'%(app),'core/app/test.html'])
    c = RequestContext(request,
                      {'test': test,'test_metrics':test_metrics,'summary':summary},
                      [defaultContext] 
                    )
    return HttpResponse(t.render(c))

  def testlist(self,request,list_type,dic={'Test':None},*args,**kwargs):

    test = dic['Test']
    app  = test.__module__.split('.')[1]

    if not list_type in  ['all','scheduled','submitting','error','running','completed']:
        raise Http404

    list_type = 'testlist'+str(list_type)

    #Here there is no customization allowed.
    return render_to_response('core/app/testlist.html', locals(), context_instance = RequestContext(request))


#######################################################
## AJAX BLOCK
#######################################################

  def get_list(self,request,type,test_id,dic={'SummaryTest':None,'SummaryTestSite':None},*args,**kwargs):

    summary_test = dic['SummaryTest']
    app          = summary_test.__module__.split('.')[1]

    summary_test_site = dic['SummaryTestSite']

    searchableColumns = []
    jsonTemplatePath = 'core/app/json/'

    if type == 'testsites':
      querySet = summary_test_site.objects.filter(test__id=test_id)
      columnIndexNameMap = {0:'test_site__site__name',1:'submitted',2:'running',3:'completed',4:'failed',5:'test_site__num_datasets_per_bulk',6:'test_site__min_queue_depth',7:'test_site__max_running_jobs',8:'test_site__resubmit_enabled',9:'test_site__resubmit_force',10:'test_site__site__name'}
      jsonTemplatePath += 'testsites.txt'

    elif type == 'testsummary':
      querySet = summary_test_site.objects.filter(test__id=test_id)
      metr = querySet[0].test.metrics.summary.all() 
      columnIndexNameMap = {0:'test_site__site__name'} 
      for i in xrange(0,len(metr)):
#        table_redirect = ''
        metric = metr[i].name
#        if not metric in ['submitted','running','completed','failed','total','c_cf','c_t','s_t','r_t','f_t']:        
#          table_redirect = 's_metric__'
        columnIndexNameMap[i+1] = metr[i].name

      searchableColumns = {'site':'testsite__site__name'}
      jsonTemplatePath = str(app)+'/json/'+str(querySet[0].test.metrics.name)+'.txt'

    elif type.startswith('testlist'):

      mode = type.replace('testlist','')
      if mode == 'all':
        querySet = summary_test.objects.all()
      elif mode in ['scheduled','submitting','error','running','completed']:
        querySet = summary_test.objects.filter(test__state=mode)
      else:
        raise Http404

      columnIndexNameMap = {0:'test__id',1:'test__state',2:'test__host__name',3:'clouds',4:'test__template__id',5:'test__inputtype',6:'test__starttime',7:'test__endtime',8:'nr_sites',9:'total',10:'test__id'}
      jsonTemplatePath += 'testlist.txt'

    else:
      raise Http404

    return get_records(request, querySet, columnIndexNameMap, searchableColumns, jsonTemplatePath, type, app)


  def testaccordion(self,request,test_id,type,dic={'Test':None},*args,**kwargs):

    test = dic['Test']
    app  = test.__module__.split('.')[1]

    ACCORDION = ['testsites','testsummary','testbackend','testapplication','testreasons','testcompleted','teststdouterr']
    list = False

    if not type in ACCORDION:
      raise Http404

    test = get_object_or_404(test,pk=test_id)
    table = type

    items = []
    if type == 'testsummary':
      table = test.metrics.name

#    elif type == 'testbackend':
#        dh = HCDataHelper()
#        items = dh.annotateBackendExitCodes(test)
#    elif type == 'testapplication':
#        dh = HCDataHelper()
#        items = dh.annotateApplicationExitCodes(test)
#    elif type == 'testreasons':
#        dh = HCDataHelper()
#        items = dh.annotateBackendReasons(test)
#    elif type == 'testcompleted':
#        dh = HCDataHelper()
#        items = dh.annotateExampleCompletedJobs(test)
#    elif type == 'teststdouterr':
#        dh = HCDataHelper()
#        items = dh.annotateStdouterr(test)

    t = loader.select_template(['%s/ajax/%s.html'%(app,table),'core/app/ajax/%s.html'%(table)])
    c = Context({'test_id': test_id,'list':list,'type':type,'items':items,'app':app})
    return HttpResponse(t.render(c))


#  def ajaxtestmetrics(self,request,test_id,dic={'Test':None},*args,**kwargs):
#    app = dic['Test'].__module__.split('.')[1]
#    try:
#      test = dic['Test'].objects.get(pk=test_id)
#    except:
#      raise Http404
#    dh   = Datahelper()
#    test = dh.annotateTestPerMetric(test)
#    t = loader.select_template(['%s/testmetrics.html'%(app),'core/app/testmetrics.html'])
#    c = Context({'test': test})
#    return HttpResponse(t.render(c))


#  def ajaxsitemetrics(self,request,test_id,dic={'Test':None},*args,**kwargs):
#    app = dic['Test'].__module__.split('.')[1]
#    try:
#      test = dic['Test'].objects.get(pk=test_id)
#    except:
#      raise Http404
#    dh   = Datahelper()
#    test = dh.annotateTestPerSite(test)
#    t = loader.select_template(['%s/sitemetrics.html'%(app),'core/app/sitemetrics.html'])
#    c = Context({'test': test})
#    return HttpResponse(t.render(c))


#######################################################
## ROBOT BLOCK
#######################################################

  def robot(self,request,dic={'Site':None,'Cloud':None},*args,**kwargs):

    site = dic['Site']
    app  = site.__module__.split('.')[1]
  
    sites = site.objects.order_by('cloud')
    cloud = dic['Cloud']
    clouds =  cloud.objects.all()

    dh = Datahelper()

    sites = dh.annotateSitesEfficiency(sites)  

    t = loader.select_template(['%s/robot.html'%(app),'core/app/robot.html'])
    c = RequestContext(request,
                      {'sites': sites,'clouds':clouds},
                      [defaultContext]
                    )
    return HttpResponse(t.render(c))

#######################################################
## STATS BLOCK
#######################################################

  def stats(self,request,dic={'Site':None,'Result':None,'Cloud':None,'Template':None,'Test':None},*args,**kwargs):

    site = dic['Site']
    app  = site.__module__.split('.')[1]

    template  = dic['Template']
    test = dic['Test']
    cloud  = dic['Cloud']

    ## Overall 
    
    result  = dic['Result']
    total = result.objects.count()
    completed = result.objects.filter(ganga_status='c').count()
    failed = result.objects.filter(ganga_status='f').count()
    
    completed_total, failed_total = 0,0
    if total:
      completed_total = float(completed)/float(total)
      failed_total    = float(failed)/float(total)

    version = test.objects.all().aggregate(Max('version'))['version__max']
    since   = test.objects.all().aggregate(Min('starttime'))['starttime__min']
    vsince  = test.objects.filter(version=version).aggregate(Min('starttime'))['starttime__min']

    ##### Overall plot

    completed_plot = result.objects.filter(ganga_status='c').values('test__version').annotate(count=Count('test__version'))
    failed_plot    = result.objects.filter(ganga_status='f').values('test__version').annotate(count=Count('test__version'))

    overall_plot = []
    overall_labl = []

    #If they have different lenghts, it will crash
    for i in xrange(0,len(completed_plot)):
      overall_plot.append(completed_plot[i]['count'])
      overall_labl.append('C v.'+str(completed_plot[i]['test__version']))
      overall_plot.append(failed_plot[i]['count'])
      overall_labl.append('F v.'+str(failed_plot[i]['test__version']))    

    from hc.core.utils.plots.charts import pie
    overall_url = pie(overall_plot,overall_labl,'')

    ## Sites

    sites = site.objects.count()
    clouds = cloud.objects.count()

    sites_per_cloud = list(site.objects.values('cloud').annotate(count=Count('cloud')).order_by('count'))
    max_site_per_cloud,min_site_per_cloud = {},{}

    sites_plot = []
    sites_labl = []

    for s_p_c in sites_per_cloud:
      c = get_object_or_404(cloud,pk=s_p_c['cloud'])
      sites_plot.append(s_p_c['count'])
      sites_labl.append(c.code)

    sites_url = pie(sites_plot,sites_labl,'')

    if sites_per_cloud:
      min = sites_per_cloud[0]
      max = sites_per_cloud.pop()
      cloudM = get_object_or_404(cloud,pk=max['cloud'])
      cloudm = get_object_or_404(cloud,pk=min['cloud'])
      max_site_per_cloud = [(max['count'],cloudM)]
      min_site_per_cloud = [(min['count'],cloudm)]

    sites_per_cloud = 0
    if clouds and sites:
      sites_per_cloud = float(sites)/float(clouds)

    ## Users
    
    from django.contrib.auth.models import User
    users = User.objects.filter(groups__name__startswith=app).distinct().count()

    ## Tests

    templates = template.objects.count()

    tests = test.objects.count()

    tests_per_template = list(test.objects.values('template').annotate(count=Count('template')).order_by('count'))

    tests_plot = []
    tests_labl = []

    for t_p_t in tests_per_template:
      t = get_object_or_404(template,pk=t_p_t['template'])
      tests_plot.append(t_p_t['count'])
      tests_labl.append(t.id)

    tests_url = pie(tests_plot,tests_labl,'')


    max_test_per_template,min_test_per_template = {},{}
    if tests_per_template:
      min = tests_per_template[0]
      max = tests_per_template.pop()
      templateM = get_object_or_404(template,pk=max['template'])
      templatem = get_object_or_404(template,pk=min['template'])
      max_test_per_template = [(max['count'],templateM)]
      min_test_per_template = [(min['count'],templatem)]

    tests_per_template = 0
    if tests and templates:
      tests_per_template = float(tests)/float(templates)

    t = loader.select_template(['%s/stats.html'%(app),'core/app/stats.html'])
    c = RequestContext(request,
#                      {'sites': sites,'results':results,'users':users,'clouds':cloud,''},
                      locals(),
                      [defaultContext]
                    )
    return HttpResponse(t.render(c))

  def plots(self,request,dic={'MetricType':None,'Test':None,'Site':None,'Cloud':None,'Host':None,'Template':None},*args,**kwargs):

    metric_type = dic['MetricType']
    test        = dic['Test']
    cloud       = dic['Cloud']
    site        = dic['Site']
    template    = dic['Template']
    app = metric_type.__module__.split('.')[1]

    obj = {}
    obj['metric_type'] = metric_type
    obj['test']        = test
    obj['cloud']       = cloud
    obj['site']        = site
    obj['template']    = template

    metric_types = metric_type.objects.all()
    tests        = test.objects.all()
    clouds       = cloud.objects.all()
    templates    = template.objects.all()

    for cloud in clouds:
      cloud.sites = cloud.getSites_for_cloud.all()

    ## PLOT GENERATOR ##

    query = {}
    pre   = {}

    query['metric_type']     = request.GET.getlist('metric_type')
    query['site']            = request.GET.getlist('site')
    query['cloud']           = request.GET.getlist('cloud')
    query['test']            = request.GET.getlist('test')
    query['template']        = request.GET.getlist('template')

    plot       = request.GET.get('plot','')    
    combine    = request.GET.get('combine','')
    sort_by    = request.GET.get('sort_by','')

    plots = []
    error = ''

    Qobjects = {}
#    Pobjects = {}

    try:

      for key,values in query.items():
        Qobjects[key] = []
        for item in values:
          id = int(item)
          Qobjects[key].append(get_object_or_404(obj[key],pk=id))

    except:
      error = 'An error ocurred. Please contact admin if it occurs again.'

    if not plot:
     
      dialog   = []

      for class_name,class_instance in obj.items():
        
        if not Qobjects.has_key(class_name):   

          if class_name == 'template' and Qobjects['test']:
            pass
          elif class_name == 'cloud' and Qobjects['site']:
            pass
          elif class_name == 'site':
            dialog += [(class_name,clouds)]
          else:
            dialog += [(class_name,class_instance.objects.all())]

        else:
          if class_name == 'site':
            clouds = list(clouds)
            for item in Qobjects[class_name]:
              if item.cloud in clouds:
                cloud_index = clouds.index(item.cloud)               
                cloud = clouds[cloud_index]                
                if item in cloud.sites:
                  cloud.sites = list(cloud.sites)
                  index = cloud.sites.index(item)
                  cloud.sites.remove(item)
                  item.selected = 'selected'                 
                  cloud.sites.insert(index,item)

            dialog += [(class_name,clouds)]          
          else:
            class_instance_objs = list(class_instance.objects.all())
            for item in Qobjects[class_name]:          
              if item in class_instance_objs:
                index = class_instance_objs.index(item)
                class_instance_objs.remove(item)
                item.selected = 'selected'
                class_instance_objs.insert(index,item)
            
            dialog += [(class_name,class_instance_objs)]

      t = loader.select_template(['%s/plots.html'%(app),'core/app/plots.html'])
      c = RequestContext(request,
                      {'dialog':dialog,'error':error,'plot':plot,'sort_by':sort_by},
                      [defaultContext]
                    )
      return HttpResponse(t.render(c))

    if plot:

      ##
      ## REMOVE DUPLICATED FROM METRIC LIST ??
      ## IF PRE, NOT Q                      ??
      ##

      if not Qobjects['metric_type']:
        error = 'Please, select at least one metric.'

#       # WTF, is this really needed ?
#      if Pobjects['metric_type'] and not Pobjects['metric_type'] in metric_list:
#        metric_list += [Pobjects['metric_type']]

      if not error and not(Qobjects['site'] or Qobjects['cloud'] or Qobjects['test'] or Qobjects['template']):
        error = 'Please, select a filter for this metric type.'

      if Qobjects['cloud'] and Qobjects['site']:
        error = 'Please, decide if you want to filter either by site or by cloud.'

#      if Qobjects['test'] and Qobjects['template']:
#        error = 'Please, decide if you want to filter either by test or by template.'

      if not error:

        from hc.core.utils.plots.charts import hist

        plots = {}

        for metr in Qobjects['metric_type']:

          if sort_by == 'cloud':
            if not Qobjects[sort_by]:
              error = 'You must select at least one %s.'%(sort_by)
            elif Qobjects['test'] and Qobjects['template']:
              error = 'Please, decide if you want to filter either by test or by template.'

            else:
              for cloud in Qobjects[sort_by]:
                values = []
                title  = 'Cloud %s.'%(cloud.name)
                sites  = cloud.getSites_for_cloud.all()                 

                plot_list = []

                #Overall 
                val_list = []
                for site in sites:
                  val_list += site.getResults_for_site.filter(ganga_status='c').values(metr.name).all()
                values = [('Overview.',val_list)]
 
                if Qobjects['test']:
                  for test in Qobjects['test']:
                    val_list = []
                    for site in sites:
                      val_list += site.getResults_for_site.filter(ganga_status='c').filter(test=test).values(metr.name).all()
                    values += [('Test %s.'%(test.id),val_list)]

                elif Qobjects['template']:  
                  for template in Qobjects['template']:
                    val_list = []
                    tests = template.getTests_for_template.all()
                    for test in tests:
                      for site in sites:
                        val_list += site.getResults_for_site.filter(ganga_status='c').filter(test=test).values(metr.name).all()
                    values += [('Template %s.'%(template.id),val_list)] 

#                else:
#                  val_list = []
#                  for site in sites:
#                    val_list += site.getResults_for_site.filter(ganga_status='c').values(metr.name).all()                     
#                  values = [('Overview.',val_list)]

                for plot_title,value in values:
                  rate = [ dic[metr.name] for dic in value ]
                  url = hist(rate, 20, metr.name, plot_title)
                  if url:
                    plot_list += [url]

                if not plots.has_key(title):
                  plots[title] = []
                plots[title] += [(metr.title,plot_list)]                             

          elif sort_by == 'site':
            if not Qobjects[sort_by]:
              error = 'You must select at least one %s.'%(sort_by)
            elif Qobjects['test'] and Qobjects['template']:
              error = 'Please, decide if you want to filter either by test or by template.'
            else:
              for site in Qobjects[sort_by]:
                values = []
                title  = 'Site %s.'%(site.name)

                plot_list = []

                #Overview
                values = [('Overview',site.getResults_for_site.filter(ganga_status='c').values(metr.name).all())]

                if Qobjects['test']:
                  for test in Qobjects['test']:
                    values += [('Test %s'%(test.id),site.getResults_for_site.filter(ganga_status='c').filter(test=test).values(metr.name).all())]

                elif Qobjects['template']:
                  for template in Qobjects['template']:
                    tests = template.getTests_for_template.all()
                    val_list = []
                    for test in tests:
                      val_list += site.getResults_for_site.filter(ganga_status='c').filter(test=test).values(metr.name).all()
                    values += [('Template %s'%(template.id),val_list)]

#                else:
#                  values = [('Overview',site.getResults_for_site.filter(ganga_status='c').values(metr.name).all())]

                for plot_title,value in values:
                  rate = [ dic[metr.name] for dic in value ]
                  url = hist(rate, 20, metr.name, plot_title)
                  if url:
                    plot_list += [url]

                if not plots.has_key(title):
                  plots[title] = []
                plots[title] += [(metr.title,plot_list)]

          elif sort_by == 'test':
            if not Qobjects[sort_by]:
              error = 'You must select at least one %s.'%(sort_by)
            elif Qobjects['test'] and Qobjects['template']:
              error = 'Please, decide if you want to filter either by test or by template.'
            else:
              for test in Qobjects[sort_by]:
                values = []
                title = 'Test %s'%(test.id)

                plot_list = []

                #Overview
                values = [('Overview',test.getResults_for_test.filter(ganga_status='c').values(metr.name).all())]

                if Qobjects['site']:
                  for site in Qobjects['site']:
                    values += [(site.name,test.getResults_for_test.filter(ganga_status='c').filter(site=site).values(metr.name).all())]

                elif Qobjects['cloud']:
                  for cloud in Qobjects['cloud']:
                    val_list = [] 
                  for site in cloud.getSites_for_cloud.all():
                    val_list += test.getResults_for_test.filter(ganga_status='c').filter(site=site).values(metr.name).all()
                  values += [(cloud.name,val_list)]

#                else:
#                  values = [('Overview',test.getResults_for_test.filter(ganga_status='c').values(metr.name).all())]

                for plot_title,value in values:
                  rate = [ dic[metr.name] for dic in value ]
                  url = hist(rate, 20, metr.name, plot_title)
                  if url:
                    plot_list += [url]

                if not plots.has_key(title):
                  plots[title] = []
                plots[title] += [(metr.title,plot_list)]

          elif sort_by == 'template':
            if not Qobjects[sort_by]:
              error = 'You must select at least one %s.'%(sort_by)
            else:
              for template in Qobjects[sort_by]:
                values = []
                title  = 'Template %s.'%(template.id)

                plot_list = []

                #Overview
                val_list = []
                for test in template.getTests_for_template.all():
                  val_list += test.getResults_for_test.filter(ganga_status='c').values(metr.name).all()
                values = [('Overview',val_list)]

                if Qobjects['test']:

                  sites = []
                  for site in Qobjects['site']:
                    sites += [site]
                  for cloud in Qobjects['cloud']:
                    for site in cloud.getSites_for_cloud.all():
                      sites += [site]

                  if sites: #get by_test with given sites
                    for test in Qobjects['test']:
                      if test.template == template:
                        val_list = []
                        for site in sites:
                          val_list += test.getResults_for_test.filter(ganga_status='c').filter(site=site).values(metr.name).all()
                        values += [('Test %s'%(test.id),val_list)]

                  else: #get by_test with all possible sites
                    for test in tests:
                      if test.template == template:
                        values += [('Test %s'%(test.id),test.getResults_for_test.filter(ganga_status='c').values(metr.name).all())]

                else:
                  tests = template.getTests_for_template.all() 
                
                  if Qobjects['site']: 
                    for site in Qobjects['site']:
                      val_list = []
                      for test in tests:
                        val_list += test.getResults_for_test.filter(ganga_status='c').filter(site=site).values(metr.name).all()
                      values += [(site.name,val_list)]  

                  elif Qobjects['cloud']:
                    for cloud in Qobjects['cloud']:
                      val_list = []
                      for site in cloud.getSites_for_cloud.all():
                        for test in tests:
                          val_list += test.getResults_for_test.filter(ganga_status='c').filter(site=site).values(metr.name).all()
                      values += [(cloud.name,val_list)]

#                  else: #get overview
#                    val_list = []
#                    for test in tests:
#                      val_list += test.getResults_for_test.filter(ganga_status='c').values(metr.name).all()
#                    values = [('Overview',val_list)]                          

                for plot_title,value in values:
                  rate = [ dic[metr.name] for dic in value ]
                  url = hist(rate, 20, metr.name, plot_title)
                  if url:
                    plot_list += [url]

                if not plots.has_key(title):
                  plots[title] = []
                plots[title] += [(metr.title,plot_list)]

          elif sort_by == 'metric':
            if not Qobjects[sort_by]:
              error = 'You must select at least one %s.'%(sort_by)
            elif Qobjects['test'] and Qobjects['template']:
              error = 'Please, decide if you want to filter either by test or by template.'
            else:
              values = []
              title = 'Metric %s'%(metr.title)

      #Sort dictionary
      keys = plots.keys()
      keys.sort()
      plots = [(key,plots[key]) for key in keys]


    ## END PLOT GENERATOR ##

    t = loader.select_template(['%s/plots.html'%(app),'core/app/plots.html'])
    c = RequestContext(request,
                      {'plots':plots,'error':error},
                      [defaultContext]
                    )
    return HttpResponse(t.render(c))

  def ranks(self,request,dic={'MetricType':None,'Test':None,'Site':None,'Cloud':None,'Host':None,'Template':None},*args,**kwargs):

    metric_type = dic['MetricType']
    test        = dic['Test']
    cloud       = dic['Cloud']
    site        = dic['Site']
    template    = dic['Template']
    app = metric_type.__module__.split('.')[1]

    obj = {}
    obj['metric_type'] = metric_type
    obj['test']        = test
    obj['cloud']       = cloud
    obj['site']        = site
    obj['template']    = template

    metric_types = metric_type.objects.all()
    tests        = test.objects.all()
    clouds       = cloud.objects.all()
    templates    = template.objects.all()

    for cloud in clouds:
      cloud.sites = cloud.getSites_for_cloud.all()

    ## RANK GENERATOR ##

    query = {}

    query['metric_type']     = request.GET.getlist('metric_type')
    query['site']            = request.GET.getlist('site')
    query['cloud']           = request.GET.getlist('cloud')
    query['test']            = request.GET.getlist('test')
    query['template']        = request.GET.getlist('template')

    rank       = request.GET.get('rank','')
    combine    = request.GET.get('combine','')
    sort_by    = request.GET.get('sort_by','')

    ranks = []
    error = ''

    Qobjects = {}

    try:

      for key,values in query.items():
        Qobjects[key] = []
        for item in values:
          id = int(item)
          Qobjects[key].append(get_object_or_404(obj[key],pk=id))

    except:
      error = 'An error ocurred. Please contact admin if it occurs again.'

    if not rank:

      dialog   = []

      for class_name,class_instance in obj.items():

        if not Qobjects.has_key(class_name):

          if class_name == 'template' and Qobjects['test']:
            pass
          elif class_name == 'cloud' and Qobjects['site']:
            pass
          elif class_name == 'site':
            dialog += [(class_name,clouds)]
          else:
            dialog += [(class_name,class_instance.objects.all())]

        else:
          if class_name == 'site':
            clouds = list(clouds)
            for item in Qobjects[class_name]:
              if item.cloud in clouds:
                cloud_index = clouds.index(item.cloud)
                cloud = clouds[cloud_index]
                if item in cloud.sites:
                  cloud.sites = list(cloud.sites)
                  index = cloud.sites.index(item)
                  cloud.sites.remove(item)
                  item.selected = 'selected'
                  cloud.sites.insert(index,item)

            dialog += [(class_name,clouds)]
          else:
            class_instance_objs = list(class_instance.objects.all())
            for item in Qobjects[class_name]:
              if item in class_instance_objs:
                index = class_instance_objs.index(item)
                class_instance_objs.remove(item)
                item.selected = 'selected'
                class_instance_objs.insert(index,item)

            dialog += [(class_name,class_instance_objs)]

      t = loader.select_template(['%s/ranks.html'%(app),'core/app/ranks.html'])
      c = RequestContext(request,
                      {'dialog':dialog,'error':error,'rank':rank,'sort_by':sort_by},
                      [defaultContext]
                    )
      return HttpResponse(t.render(c))

    else:

      if not error and not(Qobjects['site'] or Qobjects['cloud'] or Qobjects['test'] or Qobjects['template']):
        error = 'Please, select a filter for this metric type.'

      if Qobjects['cloud'] and Qobjects['site']:
        error = 'Please, decide if you want to filter either by site or by cloud.'

      if not error:

        ranks = {}

        stats = Stats()
        ranks,error = stats.process(Qobjects,sort_by,'rank')

    t = loader.select_template(['%s/ranks.html'%(app),'core/app/ranks.html'])
    c = RequestContext(request,
                      {'metrics':Qobjects['metric_type'],'ranks':ranks,'error':error},
                      [defaultContext]
                    )
    return HttpResponse(t.render(c))

